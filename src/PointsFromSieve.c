// Fixed on 03-19-2019 by Rodney DuPlessis (type mismatches)#include <stdio.h>#include <stdlib.h>/* ----------------- Type definitions ----------------------------------- */typedef  struct                     /* period ( congruence class )         */{   int mod;                       /* modulus of the period               */   int ini;                       /* starting point                      */}  periode;typedef  struct                     /* intersection of several periods     */{   int    clnb;                   /* number of terms in the intersection */   periode  *cl;                    /* terms in the intersection           */   periode  clr;                    /* resulting period                    */   unsigned long ptval;             /* current point value                 */}  inter;/*  Function prototype */periode  ReducInter(short u);          /* computation of the intersections *//* ----------------- variables ------------------------------------------- */inter    *fCrib;                    /* sieve formula                       */int    unb = 0;                   /* number of unions in the formula     */short    u0, u1, u = 0;             /* current union index                 */short    i = 0;                     /* current intersection index          */unsigned long lastval,n0,ptnb = 0;periode  CL_EMPTY = { 0, 0 };       /* empty period                        */#define  NONEMPTY    1short    flag        = 0;short    decomp      = 0;/* ========================== Euclide's algorithm ======================== */short Euclide (a1, a2)     /* a1 >= a2 > 0 */short a1;short a2;{   short tmp;   while ((tmp = a1 % a2) != 0)      {      a1 = a2;      a2 = tmp;      }   return a2;}/* ========================== De Meziriac's theorem ====================== */short Meziriac (c1, c2)    /* c1 >= c2 > 0 */short c1;short c2;{   short T = 0;   if (c2 == 1)      T = 1;   else      while (((++T * c1) % c2) != 1)         ;   return T;}/* =============Decomposition into an intersection of prime modules  ====== */  void  Decompos (periode pr){   periode  pf;   short    fct;   if (pr.mod == 0)      {      printf(" = (%d,%d)\n", pr.mod, pr.ini);      return;      }   printf(" =");   for ( i = 0, fct = 2; pr.mod != 1; fct++)      {      pf.mod = 1;      while (pr.mod % fct == 0 && pr.mod != 1)         {         pf.mod   *= fct;         pr.mod   /= fct;         }      if (pf.mod != 1)         {         pf.ini = pr.ini % pf.mod;         pr.ini %= pr.mod;         if (i != 0)            printf(" *");         printf(" (%d,%d)", pf.mod, pf.ini);         i++;         }      }   printf("\n");}/* ======================================================================= */void main(void){   printf("SIEVES: user's guide\n\n"          "A. GENERATION OF POINTS ON A STRAIGHT LINE FROM\n"          "   THE LOGICAL FORMULA OF THE SIEVE\n\n"          "Example:\n"          "---------------------------------\n"          "DEFINITION OF A SIEVE:\n"          "    L =   [() * () * ... * ()]\n"          "        + [() * () * ... * ()]\n"          "        + ...\n"          "        + [() * () * ... * ()]\n\n"          "In each parenthesis are given in order: modulus, starting point\n"          "                             (taken from the set of integers)\n"          "[] + [] is a union\n"          "() * () is an intersection\n\n");   printf("---------------------------------\n"          "Given the formula of a sieve made out of unions and\n"          "intersections of moduli, the program reduces the number of\n"          "intersections to one and keeps only the given unions.\n"          "Then, the abscissa of the final points of the sieve are\n"          "computed from these unions and displayed.\n\n");   /* -------------- get the formula of the sieve ------------------------ */   while (unb == 0)      {      printf("NUMBER OF UNIONS? = ");      scanf("%d",&unb);      }   fCrib = (inter *)(malloc (sizeof(inter) * unb));   if (fCrib == NULL)      {      printf("not enough memory\n");      exit(1);      }   printf("---------------------------------\n");   for (u = 0; u < unb; u++)      {      printf("union %d: number of modules? = ", u + 1);      scanf("%d",&fCrib[u].clnb);      printf("\n");      fCrib[u].cl = (periode *)(malloc (sizeof(periode) * fCrib[u].clnb));      if (fCrib[u].cl == NULL)         {         printf("not enough memory\n");          exit(1);         }      for (i = 0; i < fCrib[u].clnb; i++)         {         printf("\n                      modulus %d? = ", i + 1);         scanf("%d",&fCrib[u].cl[i].mod);         printf("                      start?     = ");         scanf("%d",&fCrib[u].cl[i].ini);         }      printf("---------------------------------\n");      }   /* -------------- reduction of the formula ---------------------------- */   printf("FORMULA OF THE SIEVE:\n\n"          "     L =  [   ");   for (u = 0; u < unb; u++)      {      if (u != 0)         printf("        + [   ");      for (i = 0; i < fCrib[u].clnb; i++)         {         if (i != 0)            {            if (i % 4 == 0)               printf("\n            ");            printf("* ");            }         printf("(%5d,%5d) ", fCrib[u].cl[i].mod, fCrib[u].cl[i].ini);         }      printf("]\n");      }   printf("---------------------------------\n");   printf("REDUCTION OF THE INTERSECTIONS:\n\n");   for (u = 0; u < unb; u++)      {      printf("union %d\n       [ ",u + 1);      for (i = 0; i < fCrib[u].clnb; i++)         {         printf("(%d,%d) ", fCrib[u].cl[i].mod, fCrib[u].cl[i].ini);         if (i != fCrib[u].clnb - 1)            printf("* ");         }      fCrib[u].clr = ReducInter(u);    /* reduction of an intersection */      printf("] = (%d,%d)\n\n", fCrib[u].clr.mod, fCrib[u].clr.ini);      printf("       Decomposition into prime modules ?\n"             "       (press 'y' for yes, any other key for no): ");      if (getchar() == 'y')         {         printf("\n\n       (%d,%d)", fCrib[u].clr.mod, fCrib[u].clr.ini);         Decompos(fCrib[u].clr);         }      else         printf("\n\n");      }   printf("---------------------------------\n");   /* -------------- display the simplified formula ---------------------- */   printf("SIMPLIFIED FORMULA OF THE SIEVE:\n\n");   printf("     L =   ");   for (u = 0; u < unb; u++)      {      if (u != 0)         {         if (u % 4 == 0)            printf("\n         ");         printf("+ ");         }      printf("(%5d,%5d) ", fCrib[u].clr.mod, fCrib[u].clr.ini);      }   printf("\n---------------------------------\n");   /* -------------- points of the sieve --------------------------------- */   printf("POINTS OF THE SIEVE CALCULATED WITH THIS FORMULA:\n");   printf("Rank of first displayed point? = ");   scanf("%lu",&n0);   n0 = n0 - n0 % 10;   printf("\npress <enter> to get a series of 10 points\n\n"          "Rank    |");   for (u = 0; u < unb; u++)      {      if (fCrib[u].clr.mod != 0 || fCrib[u].clr.ini != 0)         {         fCrib[u].ptval = fCrib[u].clr.ini;         flag = NONEMPTY;         }      else         fCrib[u].ptval = 0xFFFFFFFF;      }   if (flag != NONEMPTY)      return;   u0 = u1 = 0;   lastval = 0xFFFFFFFF;   while (1)      {      for (u = (u0 + 1) % unb; u != u0; u = (u + 1) % unb)         {         if (fCrib[u].ptval <= fCrib[u1].ptval)            u1 = u;         }      if (fCrib[u1].ptval != lastval)  /* new point */         {         lastval = fCrib[u1].ptval;         if (ptnb >= n0)            {            if (ptnb % 10 == 0)               {               getchar();    /* get a character from the keyboard */               printf("\n%7lu |", ptnb);               }            printf("%6lu ", fCrib[u1].ptval);            }         ptnb++;         }      fCrib[u1].ptval += fCrib[u1].clr.mod;      u0 = u1;      }}/* ========================== Reduction of an intersection =============== */periode ReducInter(short u){   periode  cl,cl1,cl2,cl3;   short    pgcd,T,n;   long     c1,c2;   cl3 = fCrib[u].cl[0];   for (n = 1; n < fCrib[u].clnb; n++)      {      cl1 = cl3;      cl2 = fCrib[u].cl[n];      if (cl1.mod < cl2.mod)         {         cl    = cl1;         cl1   = cl2;         cl2   = cl;         }      if (cl1.mod != 0 && cl2.mod != 0)         {         cl1.ini %= cl1.mod;         cl2.ini %= cl2.mod;         }      else         return CL_EMPTY;      /* module resulting from the intersection of 2 modules */      pgcd  = Euclide(cl1.mod, cl2.mod);      c1    = cl1.mod / pgcd;      c2    = cl2.mod / pgcd;      if (pgcd != 1          && ( (cl1.ini - cl2.ini) % pgcd != 0 ))         return CL_EMPTY;      if (pgcd != 1          && ((cl1.ini - cl2.ini) % pgcd == 0)          && (cl1.ini != cl2.ini) && (c1 == c2) )         {         cl3.mod = pgcd;         cl3.ini = cl1.ini;         continue;         }      T = Meziriac((short) c1, (short) c2);      cl3.mod = (short) (c1 * c2 * pgcd);      cl3.ini = (short) (( cl1.ini                 + T * (cl2.ini - cl1.ini) * c1) % cl3.mod);      while (cl3.ini < cl1.ini || cl3.ini < cl2.ini)         cl3.ini += cl3.mod;      }   return cl3;}