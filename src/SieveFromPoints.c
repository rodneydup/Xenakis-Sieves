// Fixed on 03-19-2019 by Rodney DuPlessis (type mismatches)#include <stdio.h>#include <stdlib.h>#include <string.h>/* ----------------- type definitions ----------------------------------- */typedef  struct                     /* period ( congruence class )         */{   short mod;                       /* modulus of the period               */   short ini;                       /* starting point                      */   short couv;                      /* number of covered points            */}  periode;/* ----------------- function prototypes --------------------------------- */unsigned long Euclide(unsigned long m1,                      unsigned long m2);  /* computation of the LCD        */                                            /* ----------------- variables and constants ----------------------------- */periode  *perCrib;                  /* periods of the sieve                */short    perTotNb = 0;              /* number of periods in the formula    */long     *ptCrib;                   /* points of the crible                */long     *ptReste;                  /* points outside the periods          */int    ptTotNb = 0;               /* number of points in the sieve       */short    p,ptnb;long     ptval;unsigned long percrib;periode  per;#define  NON_REDUNDANT  0#define  REDUNDANT      1#define  COVERED        -1Lshort    flag;/* ======================================================================= */void main(void){   printf("B. GENERATION OF THE LOGICAL FORMULA OF THE SIEVE FROM\n"          "   A SERIES OF POINTS ON A STRAIGHT LINE\n\n"          "Example:\n"          "---------------------------------\n"          "Given a series of points, find the starting points\n"          "with their moduli (periods).\n\n");   /* -------------- entry of the points of the sieve and their sorting -- */   while (ptTotNb == 0)      {      printf("NUMBER OF POINTS ? = ");      scanf("%d",&ptTotNb);      }   ptCrib   = (long *)(malloc (ptTotNb * sizeof(long)));   ptReste  = (long *)(malloc (ptTotNb * sizeof(long)));   perCrib  = (periode *)(malloc (ptTotNb * sizeof(periode)));   if (ptCrib == NULL || ptReste == NULL || perCrib == NULL)      {      printf("not enough memory\n");      exit(1);      }   printf("---------------------------------\n"            "abscissa of the points:\n");   for (p = 0; p < ptTotNb; p++)      {      if (p % 4 == 0)         printf("\n    ");      printf("point %2d = ", p + 1);      scanf("%ld", &ptval);      for (ptnb = 0;           ptnb < p && ptval > ptCrib[ptnb];           ptnb++)         ;      if (ptnb < p)         {         if (ptval < ptCrib[ptnb])  /* new point  */            memmove(&ptCrib[ptnb + 1], &ptCrib[ptnb],                    sizeof(long) * (p - ptnb));         else /* point already exist */            {            p--;            ptTotNb--;            }         }      ptCrib[ptnb] = ptval;      }   printf("\n---------------------------------\n");   /* -------------- points of the sieve --------------------------------- */   printf("POINTS OF THE SIEVE (ordered by their increasing abscissa):\n\n"          "Rank    |");   for (p = 0; p < ptTotNb; p++)      {      if (p % 10 == 0)         printf("\n%7d |", p);      printf("%6ld ", ptCrib[p]);      }   printf("\n\n---------------------------------\n");   /* -------------- compute the periods of the sieve -------------------- */   memcpy(ptReste, ptCrib, ptTotNb * sizeof(long));   for (p = 0; p < ptTotNb; p++)      {      if ( ptReste[p] == COVERED )         continue;      /* ----------- compute a period starting at current point ---------- */      per.mod  = 0;      do         {         per.mod++;         per.ini  =  (short) (ptCrib[p] % (long)per.mod);         per.couv = 0;         for (ptnb = 0, ptval = per.ini;              ptnb < ptTotNb && ptval >= ptCrib[ptnb];              ptnb++)            {            if (ptval == ptCrib[ptnb])               {               per.couv++;               ptval += per.mod;               }            }         }      while (ptnb < ptTotNb);      /* ----------- check the redundancy of the period ------------------ */      for (ptnb = 0, ptval = per.ini, flag = REDUNDANT;           ptnb < ptTotNb;           ptnb++)         {         if (ptval == ptCrib[ptnb])            {            if (ptval == ptReste[ptnb])               {               ptReste[ptnb] = COVERED;               flag = NON_REDUNDANT;               }            ptval += per.mod;            }         }      if (flag == NON_REDUNDANT)         perCrib[perTotNb++] = per;      }   /* -------------- compute the period of the sieve -------------------- */   percrib = perCrib[0].mod;   for (p = 1; p < perTotNb; p++)      {      if ((long) perCrib[p].mod >= percrib)         percrib *= (long) perCrib[p].mod / Euclide((long)perCrib[p].mod, percrib);      else         percrib *= (long) perCrib[p].mod / Euclide(percrib, (long)perCrib[p].mod);      }   /* -------------- display the formula of the sieve -------------------- */   printf("FORMULA OF THE SIEVE:\n"          "In each parenthesis are given in order:\n"          "(modulus, starting point, number of covered points)\n\n");   printf("     L =   ");   for (p = 0; p < perTotNb; p++)      {      if (p != 0)         {         if (p % 3 == 0)            printf("\n         ");         printf("+ ");         }      printf("(%5d,%5d,%5d) ",perCrib[p].mod,perCrib[p].ini,perCrib[p].couv);      }   printf("\n\n     period of the sieve: P = %lu\n", percrib);}/* ========================== Euclide's algorithm ======================== */unsigned long Euclide (a1, a2)     /* a1 >= a2 > 0 */unsigned long a1;unsigned long a2;{   unsigned long tmp;   while ((tmp = a1 % a2) != 0)      {      a1 = a2;      a2 = tmp;      }   return a2;}